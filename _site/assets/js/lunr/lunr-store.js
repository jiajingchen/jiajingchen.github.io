var store = [{
        "title": "STAT110: The Probability course you don't want to miss",
        "excerpt":"I have always been fascinated by probability and statistics ever since I was in high school. I have taken a few courses in probability from school and online courses. But I would say that Joe’s probability course is one of my favorite courses of all time! It helped me gasp a deeper understanding in distribution and conditional probability. It also helped me connect the dots between different distributions and their applications.   Early this year, I have been watching the videos of STAT 110 Probability by Professor Joe Blitzstein on Youtube for 3 times. I almost listened to it before I went to bed every night!   This course also served as a pre-requisite and provide a solid foundation for another stat course I took later in Spring 2018: STAT 171 Introductions to Stochastics Processes by Natesh Pillai (I also recommend this course!)   If you want to learn more about random variables and their distributions, conditional probability and a lot of other interesting stuffs related to probability, don’t forget to check out STAT 110 at the course website. There are a lot of study materials and exercise that you could learn and practice too.   Here is some videos that I like the most (if you want to get a quick gasp of what this course is about and why is this course interesting)      The “two envelope paradox”. Starting from 46:20 on Lecture 25 to the first part of Lecture 26   I would like to share one more thing quoted from Joe’s in his talk on “The Soul of Statistics” (In case you haven’t seen this video above. Here is a spoiler alert!)   “Conditional is the soul of statistics.”    P.S.  I recently heard from Joe’s twitter that “He is working on developing an edX version of Stat 110, and that will indeed have a certificate of completion.” Hopefully the course will be launching on EdX soon!    Update 2018:  I audited STAT 210 Probability in Fall 2018, a advance version of STAT 110 and it touched on more measure theory and proofs.    Update 2019:  Joe’s Introduction to Probability course launched on Edx! Check the course official website here for more! The second edition of Joe’s probability book with Jessica Hwang is free online here.  ","categories": ["stat"],
        "tags": ["probability","stat","courses"],
        "url": "http://localhost:4000/stat/post-stat110-probability/",
        "teaser": "http://localhost:4000/assets/images/thumbnails/stat110logo.jpg"
      },{
        "title": "Intro to data structure and algorithm Part I",
        "excerpt":"This is Part I of the intro to data structure and algo series. See others here.        test code block here:      DFS   class Solution:     def subsets(self, nums: List[int]) -&gt; List[List[int]]:         #backtracking         n = len(nums)         if n==0:             return []         def dfs(i, curr_path, res):             res.append(curr_path)             if len(curr_path)==n:                 return             for j in range(i,n):                 dfs(j+1, curr_path+[nums[j]], res)         res = []         curr_path = []         dfs(0, curr_path, res)         return res      BFS  ","categories": [],
        "tags": ["algorithm","data structure","dfs","bfs","graph"],
        "url": "http://localhost:4000/post-algorithm-part-1/",
        "teaser": "http://localhost:4000/assets/images/thumbnails/logo-data-structures-algorithms.png"
      },{
        "title": "The Little Schemer Reading Note Part I",
        "excerpt":"   Intro   The Little Schemer is a great book writen by Daniel P. Friedman and Matthias Felleisen. The book introduced concepts in computer science and functional programming in Scheme/Lisp. It is about recursion at its core. (Check out the cover of the book and you will find out!)   The authors mentioned in the preface that:      The goal of this book is to teach the reader to think recursively.    I really love the way the book is structured by asking questions from simple examples and let the readers to think and grasp the concepts along the process. I don’t know about LISP or Scheme programing language beforehand but I was able to pick it up through its unique Q&amp;A style of teaching (It’s fun and fascinating!).   Here is the table of contents of The Little Schemer. It’s pretty light in the first few chapters but quickly gets quite in depth. Especially in last few chapter about lambda and Y-combinator.      Chapter  1: Toys   Chapter  2: Do It, Do It Again, and Again, and Again…   Chapter  3: Cons the Magnificent   Chapter  4: Numbers Games   Chapter  5: Oh My Gawd: It’s Full of Stars   Chapter  6: Shadows   Chapter  7: Shadows   Chapter  8: Lambda the Ultimate   Chapter  9: … and Again, and Again, and Again …   Chapter 10: What Is the Value of All of This?   Resource and code   Here are some resources I found very useful when I read through the book.      the talk given by   The little schemer repo with code and examples in book   If you want to run Scheme/LISP on your computer without a Scheme interpreter. Here is a tutorial on how to do so through jupyter notebook   Ok, let’s get started! Today we are going through some basic concepts in this book and examples of how functions are defined using recursion.   Basic concepts      Basic data types:   atom: atom is the basic element   list: list   S-expression: basic element,   tup: tuple, list of number      Basic operations:   cons: concatenate between an atom and a list   car: the first element in the list   cdr: a list consists of the rest of the list l excludes its first element   eq?: check if two element are equal.   lat?: if each S-expression in the list is an atom   member? a l : if a is a member in l   rmember? a l: remove member a from list l   Examples   Here is an example of how recursion is used almost everywhere in the function definitions:   Definition of lat (Chp2 p16)   (define lat?   (lambda (l)   (cond    ((null? l) #t )      ((atom? (car l)) (lat? (cdr l)))        (else #f))))   The idea to define lat function is recurion. It first takes a look at the first element in the list car l, if it is an atom, then we will keep using the same function lat on the rest of the list cdr l. If it’s not an atom we return True #t.   Note that the first condition null? l is very important because it serves as the termination condition to the recursion. The book mentioned it several time in later chapters as well.      Up Next   In the part II we will talk more about recursion and lambda in this book. Stay tuned!   ","categories": ["book"],
        "tags": ["recursion","lisp","scheme","book"],
        "url": "http://localhost:4000/book/post-lisp-little-schemer-part-1/",
        "teaser": "http://localhost:4000/assets/images/thumbnails/The_little_schemer.jpg"
      },{
        "title": "Intro to data structure and algorithm Part II",
        "excerpt":"This is Part II of the intro to data structure and algo series. See others here.           BFS in Trees structure:   max Depth in a tree   def maxDepth(self, root: TreeNode) -&gt; int:         #non-recursive, queue         if not root:             return 0         q = collections.deque()         q.append(root)         depth = 0         while q:             depth+=1             q_size = len(q) \t\t\t  ## level-order using queue             for i in range(q_size):                 curr_node = q.popleft()                 if curr_node.left:                     q.append(curr_node.left)                 if curr_node.right:                     q.append(curr_node.right)                      return depth      BFS in graph structure:   minimum steps in an island      ","categories": [],
        "tags": ["algorithm","data structure","dfs","bfs","graph"],
        "url": "http://localhost:4000/post-algorithm-part-2/",
        "teaser": "http://localhost:4000/assets/images/thumbnails/logo-data-structures-algorithms.png"
      }]
