<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-12-03T12:43:56-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jiajing Chen</title><subtitle>Personal Website</subtitle><author><name>Jiajing Chen</name></author><entry><title type="html">Intro to data structure and algorithm Part II</title><link href="http://localhost:4000/post-algorithm-part-2/" rel="alternate" type="text/html" title="Intro to data structure and algorithm Part II" /><published>2020-11-30T00:00:00-05:00</published><updated>2020-11-30T00:00:00-05:00</updated><id>http://localhost:4000/post-algorithm-part-2</id><content type="html" xml:base="http://localhost:4000/post-algorithm-part-2/">&lt;p class=&quot;notice--primary&quot;&gt;&lt;em&gt;This is Part II of the intro to data structure and algo series. See others here.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 
 &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BFS in Trees structure:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;max Depth in a tree&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def maxDepth(self, root: TreeNode) -&amp;gt; int:
        #non-recursive, queue
        if not root:
            return 0
        q = collections.deque()
        q.append(root)
        depth = 0
        while q:
            depth+=1
            q_size = len(q)
			  ## level-order using queue
            for i in range(q_size):
                curr_node = q.popleft()
                if curr_node.left:
                    q.append(curr_node.left)
                if curr_node.right:
                    q.append(curr_node.right)
            
        return depth
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;BFS in graph structure:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;minimum steps in an island&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;</content><author><name>Jiajing Chen</name></author><category term="algorithm" /><category term="data structure" /><category term="dfs" /><category term="bfs" /><category term="graph" /><summary type="html">BFS and level order traversal using queue</summary></entry><entry><title type="html">Intro to data structure and algorithm Part I</title><link href="http://localhost:4000/post-algorithm-part-1/" rel="alternate" type="text/html" title="Intro to data structure and algorithm Part I" /><published>2020-11-20T00:00:00-05:00</published><updated>2020-11-20T00:00:00-05:00</updated><id>http://localhost:4000/post-algorithm-part-1</id><content type="html" xml:base="http://localhost:4000/post-algorithm-part-1/">&lt;p class=&quot;notice--primary&quot;&gt;&lt;em&gt;This is Part I of the intro to data structure and algo series. See others here.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 
 &lt;/p&gt;

&lt;p&gt;test code block here:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DFS&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def subsets(self, nums: List[int]) -&amp;gt; List[List[int]]:
        #backtracking
        n = len(nums)
        if n==0:
            return []
        def dfs(i, curr_path, res):
            res.append(curr_path)
            if len(curr_path)==n:
                return
            for j in range(i,n):
                dfs(j+1, curr_path+[nums[j]], res)
        res = []
        curr_path = []
        dfs(0, curr_path, res)
        return res

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;BFS&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jiajing Chen</name></author><category term="algorithm" /><category term="data structure" /><category term="dfs" /><category term="bfs" /><category term="graph" /><summary type="html">DFS and backtracking</summary></entry><entry><title type="html">The Little Schemer Reading Note Part I</title><link href="http://localhost:4000/book/post-lisp-little-schemer-part-1/" rel="alternate" type="text/html" title="The Little Schemer Reading Note Part I" /><published>2020-11-20T00:00:00-05:00</published><updated>2020-11-20T00:00:00-05:00</updated><id>http://localhost:4000/book/post-lisp-little-schemer-part-1</id><content type="html" xml:base="http://localhost:4000/book/post-lisp-little-schemer-part-1/">&lt;p&gt;The Little Schemer is a great book writen by Daniel P. Friedman and Matthias Felleisen. The book introduced concepts in computer science and functional programming in Scheme/Lisp. It is about &lt;strong&gt;recursion&lt;/strong&gt; at its core. (Check out the cover of the book and you will find out!)&lt;/p&gt;

&lt;p&gt;The authors mentioned in the &lt;a href=&quot;https://felleisen.org/matthias/BTLS-preface.html&quot;&gt;preface&lt;/a&gt; that:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;The goal of this book is to teach the reader to think recursively&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I really love the way the book is structured by asking questions from simple examples and let the readers to think and grasp the concepts along the process. I don’t know about Lisp or Scheme language beforehand but I was able to pick it up through its unique Q&amp;amp;A style of teaching (It’s fascinating!). It’s pretty light in the first few chapters but quickly gets quite in depth. Especially chapter 9 &amp;amp; 10.&lt;/p&gt;

&lt;p&gt;Here are some basic concepts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Basic data types:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;atom&lt;/code&gt;: atom is the basic element&lt;/p&gt;

&lt;p&gt;&lt;code&gt;list&lt;/code&gt;: list&lt;/p&gt;

&lt;p&gt;&lt;code&gt;S-expression&lt;/code&gt;: basic element,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tup&lt;/code&gt;: tuple, list of number&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Basic operations:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;cons&lt;/code&gt;: concatenate between an atom and a list&lt;/p&gt;

&lt;p&gt;&lt;code&gt;car l&lt;/code&gt;: the first element in the list l&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cdr&lt;/code&gt;l: a list consists of the rest of the list l excludes its first element&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eq?&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lat?l&lt;/code&gt;: if each S-expression in the list l is an atom&lt;/p&gt;

&lt;p&gt;&lt;code&gt;member?a l&lt;/code&gt; : if a is a member in l&lt;/p&gt;

&lt;p&gt;&lt;code&gt;first&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rmember?&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;Here is an example of how recursion is used almost everywhere in the function definitions:&lt;/p&gt;

&lt;p&gt;Definition of &lt;code&gt;lat&lt;/code&gt; (Chp2 p16)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define lat? 
 (lambda (l)
  (cond
   ((null? l) #t )
     ((atom? (car l)) (lat? (cdr l))) 
      (else #f))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The idea to define &lt;code&gt;lat&lt;/code&gt; function is recurion. It first takes a look at the first element in the list &lt;code&gt;car l&lt;/code&gt;, if it is an atom, then we will keep using the same function &lt;code&gt;lat&lt;/code&gt; on the rest of the list &lt;code&gt;cdr l&lt;/code&gt;. If it’s not an atom we return True &lt;code&gt;#t&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that the first condition &lt;code&gt;null? l&lt;/code&gt; is very important because it serves as the termination condition to the recursion. The book mentioned it several time in later chapters as well.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Up Next&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the part II we will talk more about recursion and lambda in this book. Stay tuned!&lt;/p&gt;</content><author><name>Jiajing Chen</name></author><category term="book" /><category term="recursion" /><category term="lisp" /><category term="scheme" /><category term="book" /><summary type="html">Recursion, recursion, and more...</summary></entry><entry><title type="html">STAT110: The Probability course you don’t want to miss</title><link href="http://localhost:4000/stat/post-stat110-probability/" rel="alternate" type="text/html" title="STAT110: The Probability course you don't want to miss" /><published>2018-05-30T00:00:00-04:00</published><updated>2018-05-30T00:00:00-04:00</updated><id>http://localhost:4000/stat/post-stat110-probability</id><content type="html" xml:base="http://localhost:4000/stat/post-stat110-probability/">&lt;p&gt;I have always been fascinated by probability and statistics ever since I was in high school. I have taken a few courses in probability from school and online courses. But I would say that Joe’s probability course is one of my favorite courses of all time! It helped me gasp a deeper understanding in distribution and conditional probability. It also helped me connect the dots between different distributions and their applications.&lt;/p&gt;

&lt;p&gt;Early this year, I have been watching the videos of STAT 110 Probability by Professor Joe Blitzstein on &lt;a href=&quot;https://www.youtube.com/playlist?list=PL2SOU6wwxB0uwwH80KTQ6ht66KWxbzTIo&quot;&gt;Youtube&lt;/a&gt; for 3 times. I almost listened to it before I went to bed every night!&lt;/p&gt;

&lt;p&gt;This course also served as a pre-requisite and provide a solid foundation for another stat course I took later in Spring 2018: STAT 171 Introductions to Stochastics Processes by &lt;a href=&quot;http://www.people.fas.harvard.edu/~pillai/&quot;&gt;Natesh Pillai&lt;/a&gt; (I also recommend this course!)&lt;/p&gt;

&lt;p&gt;If you want to learn more about random variables and their distributions, conditional probability and a lot of other interesting stuffs related to probability, don’t forget to check out STAT 110 at &lt;a href=&quot;https://projects.iq.harvard.edu/stat110&quot;&gt;the course website&lt;/a&gt;. There are a lot of study materials and exercise that you could learn and practice too.&lt;/p&gt;

&lt;p&gt;Here is some videos that I like the most (if you want to get a quick gasp of what this course is about and why is this course interesting)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The “two envelope paradox”. Starting from 46:20 on &lt;a href=&quot;https://youtu.be/2LR5JYbhyjg?list=PL2SOU6wwxB0uwwH80KTQ6ht66KWxbzTIo&amp;amp;t=2776&quot;&gt;Lecture 25&lt;/a&gt; to the first part of &lt;a href=&quot;https://www.youtube.com/watch?v=PgawcWisb0I&amp;amp;list=PL2SOU6wwxB0uwwH80KTQ6ht66KWxbzTIo&amp;amp;index=26&quot;&gt;Lecture 26&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I would like to share one more thing quoted from Joe’s in his &lt;a href=&quot;https://www.youtube.com/watch?time_continue=1&amp;amp;v=dzFf3r1yph8&quot;&gt;talk on “The Soul of Statistics”&lt;/a&gt; (In case you haven’t seen this video above. Here is a spoiler alert!)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Conditional is the soul of statistics.”&lt;/em&gt;&lt;/p&gt;

&lt;p class=&quot;notice--info text-justify&quot;&gt;&lt;i class=&quot;far fa-sticky-note&quot;&gt;&lt;/i&gt; &lt;strong&gt;P.S.&lt;/strong&gt;  I recently heard from Joe’s &lt;a href=&quot;https://twitter.com/stat110/status/557630060895932417&quot;&gt;twitter&lt;/a&gt; that “He is working on developing an edX version of Stat 110, and that will indeed have a certificate of completion.” Hopefully the course will be launching on EdX soon!&lt;/p&gt;

&lt;p class=&quot;notice--info text-justify&quot;&gt;&lt;i class=&quot;far fa-sticky-note&quot;&gt;&lt;/i&gt; &lt;strong&gt;Update 2018:&lt;/strong&gt; 
I audited STAT 210 Probability in Fall 2018, a advance version of STAT 110 and it touched on more measure theory and proofs.&lt;/p&gt;

&lt;p class=&quot;notice--info text-justify&quot;&gt;&lt;i class=&quot;far fa-sticky-note&quot;&gt;&lt;/i&gt; &lt;strong&gt;Update 2019:&lt;/strong&gt; 
Joe’s Introduction to Probability course launched on Edx! Check the course official website &lt;a href=&quot;https://www.edx.org/course/introduction-to-probability&quot;&gt;here&lt;/a&gt; for more! The second edition of Joe’s probability book with Jessica Hwang is free online &lt;a href=&quot;http://probabilitybook.net&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;</content><author><name>Jiajing Chen</name></author><category term="stat" /><category term="probability" /><category term="stat" /><category term="courses" /><summary type="html">STAT110 launched on EdX!</summary></entry></feed>